---
title: "Untitled"
knit: (function(input_file, encoding) {
  out_dir <- 'docs';
  rmarkdown::render(input_file,
 encoding=encoding,
 output_file=file.path(dirname(input_file), out_dir, 'index.html'))})
author: "Matt Twigg"
date: "June 10, 2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Libraries used
```{r libraries}
library(ggplot2)
library(tidyverse)
library(dplyr)
library("caret")
library("e1071")
library(Metrics)
```

#Introduction#
This practicum looks at business growth in Colodo and predicting that growth

#Exploration#
The first step is to load the data. This data can be downloaded from https://data.colorado.gov/Business/Business-Entities-in-Colorado/4ykn-tg5h under the "Export" button and then the "CSV" option.
```{r 1}
business <- read.csv("Business_Entities_in_Colorado.csv", header = TRUE)
```
look at the structure of the data
```{r}
str(business)
```

look at the head of the data
```{r 2}
head(business)
```
how many rows do I have
```{r 3}
totBusiness <- nrow(business)
totBusiness 
```
Let's reduce the columns to the columns I will need
```{r 4}
b1 <- business %>% select(
  entityid,
  entityname, 
  principalstate,
  principalzipcode,
  entityformdate
  )
```
Let's see the years of registration, the registrations in each of those years, and convert the year to a number at the same time
```{r 5}
date <-  as.Date(b1$entityformdate,'%m/%d/%Y')
year <- as.numeric(format(date,"%Y"))
table(year)
```
Let's add a year column to the reduced data set
```{r}
b2 <- cbind(b1, year)
str(b2)
```
Finally, let's see basic growth of registered companies in Colorado for the past 135 years
```{r }
hist(b2$year, breaks = 156)
```
I'm interested in analyzing the data by zip code but when I viewed the data I found white space and some trailing four digit delivery route data. I will trim out the leading white space
```{r}
b2$principalzipcode <- trimws(b2$principalzipcode, which = c("left"))
```
Then I take only the first 5 digits representing the zip code alone
```{r}
b2$principalzipcode <- substr(b2$principalzipcode, start = 1, stop = 5)
``` 

```{r}
plot(table(b2$principalzipcode))
```
Now I am ready to convert the zip code to a numeric value. Where there was nothing in the zip code field, it is coerced into NA values.
```{r}
b2$principalzipcode <- as.numeric(b2$principalzipcode)
```
Homestates that have registered businesses in Colorado and how many businesses
```{r}
homeStates <- table(b2$principalstate)
homeStates
```
What proportion of registered businesses are from outside Colorado?
```{r}
other <- totBusiness - homeStates["CO"]
portions <- c(other, homeStates["CO"])
states <-c("other", "Colorado")
pie(portions,labels = states, main="Registered Businesses Home State")
```
let's look at the state of the registered businesses from most registered to least. Looks like homestate is missing on a lot of the registrations.
```{r}
topHomeStates <-summary(fct_infreq(b2$principalstate))
topHomeStates
```
Colorado registrations dwarf all the others.
```{r}
barplot(topHomeStates, main="Registered Business Home State", xlab = "States")
```
I want to eliminate the count of companies that have dissolved. First I need to split off a column specifying that the company was dissolved.
```{r}
b3 <- b2 %>% separate(entityname, c("company", "dissolved"), sep = "Dissolved")
str(b3)
```
As before, I trim out leading white space in the "dissolved" column.
```{r}
b3$dissolved <- trimws(b3$dissolved, which = c("left"))
```
I need only the year dissoved. To get the year, I need to further separate out the day, month, and year and convert year to a numeric type
```{r}
tempb3 <- b3 %>% separate(dissolved, c("month", "day", "yrdslv"), sep = " ")
datedslv <-  as.Date(tempb3$yrdslv,'%Y')
yeardslv <- as.numeric(format(datedslv,"%Y"))
```
How many companies still exist? I can find this by summing the NAs in the yrdslv column. Looks like there are still a million and a half plus that are not dissolved.
```{r}
sum(is.na(tempb3$yrdslv))
```

I add the column into my dataframe
```{r}
b4 <- cbind(b3, yeardslv)
b4
```




revisit if needed

```{r}

#disornot <- grepl('Dissolved', b2$entityname)
#View(disornot)
#disornot
```

```{r}
#b2 <- cbind(b2, disornot)
#head(b2)
```



```{r}
#b4 %>%
#  separate(company, c("companyname", "disyear"), sep="\\s+(?=\\S*$)")
```

```{r}
#b5 <- b4 %>%
#  separate(company, c("companyname", "disyear"), sep="\\s+(?=\\S*$)")
```
Now we can start cleaning and reduce the number of columns in the dataframe 

```{r}
reducedb <- b4 %>% select(
  entityid,
  principalzipcode,
  year,
  yeardslv
  ) 
reducedb
```
Now, using the NA values in yeardslv, I can keep only the companies that have not been disolved
```{r}
onlyNAb <- reducedb[rowSums(is.na(reducedb)) > 0,]
onlyNAb
```
I can further reduce the rows that fall from 2010 through 2019 to get the active companies registered in those years. I still have over 800 thousand companies.
```{r}
subOnly <- onlyNAb[(onlyNAb$year > 2009) & (onlyNAb$year < 2020) ,]
subOnly
```
A table shows registrations of companies in each of those years
```{r}
table(subOnly$year)
```
A histogram of the same data makes it easer to visualize the growth of registrations
```{r }
hist(subOnly$year)
```
But I still need to separate things out by zip codes
```{r}
zips = sort(table(subOnly$principalzipcode), decreasing = TRUE)
zips
```


```{r}
sub2010Only <- onlyNAb[(onlyNAb$year > 2009) & (onlyNAb$year < 2011) ,]
only2010zips = sort(table(sub2010Only$principalzipcode), decreasing = TRUE)
top2010Zips <- only2010zips[1:1000]
#top2010Zips
```

```{r}
write.csv(top2010Zips, file = "zipsBusiness.csv")
```

##The cleaned and prepped data set
```{r}
builtDF <- read.csv("zipPopChildPrice.csv", header = TRUE)
```
##Correlations

```{r}
Xaxis <- builtDF[, "homeprice"]
Yaxis <- builtDF[, "busFormed"]
FormHomecorr <- cor(Yaxis, Xaxis, method = "pearson")
FormHomecorr
```

```{r}
Xaxis2 <- builtDF[, "children"]
Yaxis2 <- builtDF[, "busFormed"]
FormHomecorr2 <- cor(Yaxis2, Xaxis2, method = "pearson")
FormHomecorr2
```


```{r}
Xaxis2 <- builtDF[, "population"]
Yaxis2 <- builtDF[, "busFormed"]
FormHomecorr2 <- cor(Yaxis2, Xaxis2, method = "pearson")
FormHomecorr2
```
##Linear regression using population
```{r}
plot(Yaxis2~Xaxis2, col=Xaxis2)
positiveModel <- lm(Yaxis2~Xaxis2)
abline(positiveModel, col="blue")
```

```{r}
summary(lm(Yaxis2~Xaxis2))
```
## Prediction with just population
```{r}
prediction10000 <- predict(positiveModel, data.frame("Xaxis2" = 10000))
prediction10000
```
## K-means clustering




```{r}
#testBDF <- finalDF[,c(2:5)]
#growthGroup <- finalDF[, "growth"]
#testBDF
```



```{r}
result <- kmeans(builtDF, 3)
result$size
```

```{r}
table(result$cluster)
```


```{r}
growth <- rep(c("high", "medium", "low"), each = 30)
finalDF <- cbind(builtDF, growth)
finalDF
```

```{r}
table(result$cluster, growth)
```
## Train/test split
```{r}
#set.seed(7)
finalDF2 <- finalDF[,c(2:6)]
dt <- createDataPartition(growth, times = 1, p = 0.7, list = FALSE)
#dt = sort(sample(nrow(finalDF2), replace = TRUE, nrow(finalDF2)*.7))
train<-finalDF2[dt,]
test<-finalDF2[-dt,]
str(train)
```

```{r}
table(train$growth)
```


## Linear model
```{r}
model1 <- lm(busFormed ~ population + children + homeprice, train)
predicted1 <- predict(model1, test)
predicted1
```
##Fit of the linear model with the test data
```{r}
fit <- lm(busFormed ~ population + children + homeprice, data = test)
summary(fit)
```



## Running the Support Vector Machine algorithm to classify
```{r}
svmModel <- svm(growth ~., data = train, kernel = "linear")
svmModel
```
```{r}
outcome <- predict(svmModel, train)
table(Predicted = outcome, Tagged = train$growth)
```


```{r}
testOutcome <- predict(svmModel, test)
table(Predicted = testOutcome, Tagged = test$growth)
```

```{r}
plot(svmModel, data = test, busFormed ~ population)
```

##SVM as regression
## Train/test split
```{r}
#set.seed(7)
finalDF2 <- finalDF[,c(2:5)]
dt <- createDataPartition(growth, times = 1, p = 0.7, list = FALSE)
#dt = sort(sample(nrow(finalDF2), replace = TRUE, nrow(finalDF2)*.7))
train<-finalDF2[dt,]
test<-finalDF2[-dt,]
str(train)
```


```{r}
svmModel <- svm(busFormed ~., data = train, kernel = "linear")
svmModel
```

```{r}
model2 <- svm(busFormed~population, train)
predictedY <- predict(model2, test)
plot(test$population, predictedY, col = "red", pch = 4)
#pred <- predict(svmModel, test)
#x = 1: length(test$busFormed)
#plot(x, test$busFormed, pch=18, col="red")
#lines(x, pred, lwd='1', col="blue")
```




```{r}

#mse <- mse(test$busFormed, pred)
#mae = MAE(test$busFormed, pred)
#rmse = RMSE(test$busFormed, pred)
#r2 = R2(test$busFormed, pred, form = "traditional")
 
#cat(" MAE:", mae, "\n", "MSE:", mse, "\n", 
#     "RMSE:", rmse, "\n", "R-squared:", r2)
```




Fix SVM - take out growth factor
do cluster analysis

